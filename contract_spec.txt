Env Meta: AAAAAAAAABQAAAAA
 • Protocol Version: 20

Contract Meta:
 • rsver: 1.75.0
 • rssdkver: 20.2.0#6e198b79a51c48ccc8f22b02dcc4046d8cb7a887

Contract Spec:
 • Struct: InitializedEvent
     Fields:
      • factory: Address

 • Struct: AddLiquidityEvent
     Fields:
      • amount_a: I128
      • amount_b: I128
      • liquidity: I128
      • pair: Address
      • to: Address
      • token_a: Address
      • token_b: Address

 • Struct: RemoveLiquidityEvent
     Fields:
      • amount_a: I128
      • amount_b: I128
      • liquidity: I128
      • pair: Address
      • to: Address
      • token_a: Address
      • token_b: Address

 • Struct: SwapEvent
     Fields:
      • amounts: Vec(
            ScSpecTypeVec {
                element_type: I128,
            },
        )
      • path: Vec(
            ScSpecTypeVec {
                element_type: Address,
            },
        )
      • to: Address

 • Error: SoroswapRouterError
     Cases:
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapRouter: not yet initialized),
            name: StringM(NotInitialized),
            value: 401,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapRouter: negative amount is not allowed),
            name: StringM(NegativeNotAllowed),
            value: 402,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapRouter: deadline expired),
            name: StringM(DeadlineExpired),
            value: 403,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapRouter: already initialized),
            name: StringM(InitializeAlreadyInitialized),
            value: 404,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapRouter: insufficient a amount),
            name: StringM(InsufficientAAmount),
            value: 405,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapRouter: insufficient b amount),
            name: StringM(InsufficientBAmount),
            value: 406,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapRouter: insufficient output amount),
            name: StringM(InsufficientOutputAmount),
            value: 407,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapRouter: excessive input amount),
            name: StringM(ExcessiveInputAmount),
            value: 408,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapRouter: pair does not exist),
            name: StringM(PairDoesNotExist),
            value: 409,
        }

 • Error: CombinedRouterError
     Cases:
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(RouterNotInitialized),
            value: 501,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(RouterNegativeNotAllowed),
            value: 502,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(RouterDeadlineExpired),
            value: 503,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(RouterInitializeAlreadyInitialized),
            value: 504,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(RouterInsufficientAAmount),
            value: 505,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(RouterInsufficientBAmount),
            value: 506,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(RouterInsufficientOutputAmount),
            value: 507,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(RouterExcessiveInputAmount),
            value: 508,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(RouterPairDoesNotExist),
            value: 509,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(LibraryInsufficientAmount),
            value: 510,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(LibraryInsufficientLiquidity),
            value: 511,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(LibraryInsufficientInputAmount),
            value: 512,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(LibraryInsufficientOutputAmount),
            value: 513,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(LibraryInvalidPath),
            value: 514,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(),
            name: StringM(LibrarySortIdenticalTokens),
            value: 515,
        }

 • Function: initialize
     Docs: Initializes the contract and sets the factory address
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(factory),
                 type_: Address,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Tuple(
                         ScSpecTypeTuple {
                             value_types: VecM(
                                 [],
                             ),
                         },
                     ),
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: add_liquidity
     Docs: Adds liquidity to a token pair's pool, creating it if it doesn't exist. Ensures that exactly the desired amounts
           of both tokens are added, subject to minimum requirements.
           This function is responsible for transferring tokens from the user to the pool and minting liquidity tokens in return.
           # Arguments
           * `token_a` - The address of the first token to add liquidity for.
           * `token_b` - The address of the second token to add liquidity for.
           * `amount_a_desired` - The desired amount of the first token to add.
           * `amount_b_desired` - The desired amount of the second token to add.
           * `amount_a_min` - The minimum required amount of the first token to add.
           * `amount_b_min` - The minimum required amount of the second token to add.
           * `to` - The address where the liquidity tokens will be minted and sent.
           * `deadline` - The deadline for executing the operation.
           # Returns
           A tuple containing: amounts of token A and B added to the pool.
           plus the amount of liquidity tokens minted.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_a),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_b),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_a_desired),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_b_desired),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_a_min),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_b_min),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(to),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(deadline),
                 type_: U64,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Tuple(
                         ScSpecTypeTuple {
                             value_types: VecM(
                                 [
                                     I128,
                                     I128,
                                     I128,
                                 ],
                             ),
                         },
                     ),
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: remove_liquidity
     Docs: Removes liquidity from a token pair's pool.
           
           This function facilitates the removal of liquidity from a Soroswap Liquidity Pool by burning a specified amount
           of Liquidity Pool tokens (`liquidity`) owned by the caller. In return, it transfers back the corresponding
           amounts of the paired tokens (`token_a` and `token_b`) to the caller's specified address (`to`).
           
           # Arguments
           * `token_a` - The address of the first token in the Liquidity Pool.
           * `token_b` - The address of the second token in the Liquidity Pool.
           * `liquidity` - The desired amount of Liquidity Pool tokens to be burned.
           * `amount_a_min` - The minimum required amount of the first token to receive.
           * `amount_b_min` - The minimum required amount of the second token to receive.
           * `to` - The address where the paired tokens will be sent to, and from where the LP tokens will be taken.
           * `deadline` - The deadline for executing the operation.
           
           # Returns
           A tuple containing the amounts of `token_a` and `token_b` withdrawn from the pool.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_a),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_b),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(liquidity),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_a_min),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_b_min),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(to),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(deadline),
                 type_: U64,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Tuple(
                         ScSpecTypeTuple {
                             value_types: VecM(
                                 [
                                     I128,
                                     I128,
                                 ],
                             ),
                         },
                     ),
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: swap_exact_tokens_for_tokens
     Docs: Swaps an exact amount of input tokens for as many output tokens as possible
           along the specified trading route. The route is determined by the `path` vector,
           where the first element is the input token, the last is the output token,
           and any intermediate elements represent pairs to trade through if a direct pair does not exist.
           
           # Arguments
           * `amount_in` - The exact amount of input tokens to be swapped.
           * `amount_out_min` - The minimum required amount of output tokens to receive.
           * `path` - A vector representing the trading route, where the first element is the input token
           and the last is the output token. Intermediate elements represent pairs to trade through.
           * `to` - The address where the output tokens will be sent to.
           * `deadline` - The deadline for executing the operation.
           
           # Returns
           A vector containing the amounts of tokens received at each step of the trading route.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_in),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_out_min),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(path),
                 type_: Vec(
                     ScSpecTypeVec {
                         element_type: Address,
                     },
                 ),
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(to),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(deadline),
                 type_: U64,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Vec(
                         ScSpecTypeVec {
                             element_type: I128,
                         },
                     ),
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: swap_tokens_for_exact_tokens
     Docs: Swaps tokens for an exact amount of output token, following the specified trading route.
           The route is determined by the `path` vector, where the first element is the input token,
           the last is the output token, and any intermediate elements represent pairs to trade through.
           
           # Arguments
           * `amount_out` - The exact amount of output token to be received.
           * `amount_in_max` - The maximum allowed amount of input tokens to be swapped.
           * `path` - A vector representing the trading route, where the first element is the input token
           and the last is the output token. Intermediate elements represent pairs to trade through.
           * `to` - The address where the output tokens will be sent to.
           * `deadline` - The deadline for executing the operation.
           
           # Returns
           A vector containing the amounts of tokens used at each step of the trading route.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_out),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_in_max),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(path),
                 type_: Vec(
                     ScSpecTypeVec {
                         element_type: Address,
                     },
                 ),
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(to),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(deadline),
                 type_: U64,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Vec(
                         ScSpecTypeVec {
                             element_type: I128,
                         },
                     ),
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: get_factory
     Docs: This function retrieves the factory contract's address associated with the provided environment.
           It also checks if the factory has been initialized and raises an assertion error if not.
           If the factory is not initialized, this code will raise an assertion error with the message "SoroswapRouter: not yet initialized".
           https://github.com/benjaminsalon/malicious_sorochat
           # Arguments
           * `e` - The contract environment (`Env`) in which the contract is executing.
     Inputs: VecM(
         [],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Address,
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: router_pair_for
     Docs: Calculates the deterministic address for a pair without making any external calls.
           check <https://github.com/paltalabs/deterministic-address-soroban>
           
           # Arguments
           
           * `e` - The environment.
           * `token_a` - The address of the first token.
           * `token_b` - The address of the second token.
           
           # Returns
           
           Returns `Result<Address, SoroswapLibraryError>` where `Ok` contains the deterministic address for the pair, and `Err` indicates an error such as identical tokens or an issue with sorting.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_a),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_b),
                 type_: Address,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Address,
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: router_quote
     Docs: Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset.
           
           # Arguments
           
           * `amount_a` - The amount of the first asset.
           * `reserve_a` - Reserves of the first asset in the pair.
           * `reserve_b` - Reserves of the second asset in the pair.
           
           # Returns
           
           Returns `Result<i128, SoroswapLibraryError>` where `Ok` contains the calculated equivalent amount, and `Err` indicates an error such as insufficient amount or liquidity
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_a),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_a),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_b),
                 type_: I128,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: I128,
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: router_get_amount_out
     Docs: Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset.
           
           # Arguments
           
           * `amount_in` - The input amount of the asset.
           * `reserve_in` - Reserves of the input asset in the pair.
           * `reserve_out` - Reserves of the output asset in the pair.
           
           # Returns
           
           Returns `Result<i128, SoroswapLibraryError>` where `Ok` contains the calculated maximum output amount, and `Err` indicates an error such as insufficient input amount or liquidity.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_in),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_in),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_out),
                 type_: I128,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: I128,
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: router_get_amount_in
     Docs: Given an output amount of an asset and pair reserves, returns a required input amount of the other asset.
           
           # Arguments
           
           * `amount_out` - The output amount of the asset.
           * `reserve_in` - Reserves of the input asset in the pair.
           * `reserve_out` - Reserves of the output asset in the pair.
           
           # Returns
           
           Returns `Result<i128, SoroswapLibraryError>` where `Ok` contains the required input amount, and `Err` indicates an error such as insufficient output amount or liquidity.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_out),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_in),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_out),
                 type_: I128,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: I128,
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: router_get_amounts_out
     Docs: Performs chained get_amount_out calculations on any number of pairs.
           
           # Arguments
           
           * `e` - The environment.
           * `amount_in` - The input amount.
           * `path` - Vector of token addresses representing the path.
           
           # Returns
           
           Returns `Result<Vec<i128>, SoroswapLibraryError>` where `Ok` contains a vector of calculated amounts, and `Err` indicates an error such as an invalid path.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_in),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(path),
                 type_: Vec(
                     ScSpecTypeVec {
                         element_type: Address,
                     },
                 ),
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Vec(
                         ScSpecTypeVec {
                             element_type: I128,
                         },
                     ),
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: router_get_amounts_in
     Docs: Performs chained get_amount_in calculations on any number of pairs.
           
           # Arguments
           
           * `e` - The environment.
           * `amount_out` - The output amount.
           * `path` - Vector of token addresses representing the path.
           
           # Returns
           
           Returns `Result<Vec<i128>, SoroswapLibraryError>` where `Ok` contains a vector of calculated amounts, and `Err` indicates an error such as an invalid path.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_out),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(path),
                 type_: Vec(
                     ScSpecTypeVec {
                         element_type: Address,
                     },
                 ),
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Vec(
                         ScSpecTypeVec {
                             element_type: I128,
                         },
                     ),
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(CombinedRouterError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Error: SoroswapLibraryError
     Cases:
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapLibrary: insufficient amount),
            name: StringM(InsufficientAmount),
            value: 301,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapLibrary: insufficient liquidity),
            name: StringM(InsufficientLiquidity),
            value: 302,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapLibrary: insufficient input amount),
            name: StringM(InsufficientInputAmount),
            value: 303,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapLibrary: insufficient output amount),
            name: StringM(InsufficientOutputAmount),
            value: 304,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapLibrary: invalid path),
            name: StringM(InvalidPath),
            value: 305,
        }
      • ScSpecUdtErrorEnumCaseV0 {
            doc: StringM(SoroswapLibrary: token_a and token_b have identical addresses),
            name: StringM(SortIdenticalTokens),
            value: 306,
        }

 • Function: sort_tokens
     Docs: Sorts two token addresses in a consistent order.
           
           # Arguments
           
           * `token_a` - The address of the first token.
           * `token_b` - The address of the second token.
           
           # Returns
           
           Returns `Result<(Address, Address), SoroswapLibraryError>` where `Ok` contains a tuple with the sorted token addresses, and `Err` indicates an error such as identical tokens.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_a),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_b),
                 type_: Address,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Tuple(
                         ScSpecTypeTuple {
                             value_types: VecM(
                                 [
                                     Address,
                                     Address,
                                 ],
                             ),
                         },
                     ),
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(SoroswapLibraryError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: pair_for
     Docs: Calculates the deterministic address for a pair without making any external calls.
           check <https://github.com/paltalabs/deterministic-address-soroban>
           
           # Arguments
           
           * `e` - The environment.
           * `factory` - The factory address.
           * `token_a` - The address of the first token.
           * `token_b` - The address of the second token.
           
           # Returns
           
           Returns `Result<Address, SoroswapLibraryError>` where `Ok` contains the deterministic address for the pair, and `Err` indicates an error such as identical tokens or an issue with sorting.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(factory),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_a),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_b),
                 type_: Address,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Address,
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(SoroswapLibraryError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: get_reserves
     Docs: Fetches and sorts the reserves for a pair of tokens.
           
           # Arguments
           
           * `e` - The environment.
           * `factory` - The factory address.
           * `token_a` - The address of the first token.
           * `token_b` - The address of the second token.
           
           # Returns
           
           Returns `Result<(i128, i128), SoroswapLibraryError>` where `Ok` contains a tuple of sorted reserves, and `Err` indicates an error such as identical tokens or an issue with sorting.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(factory),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_a),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(token_b),
                 type_: Address,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Tuple(
                         ScSpecTypeTuple {
                             value_types: VecM(
                                 [
                                     I128,
                                     I128,
                                 ],
                             ),
                         },
                     ),
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(SoroswapLibraryError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: quote
     Docs: Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset.
           
           # Arguments
           
           * `amount_a` - The amount of the first asset.
           * `reserve_a` - Reserves of the first asset in the pair.
           * `reserve_b` - Reserves of the second asset in the pair.
           
           # Returns
           
           Returns `Result<i128, SoroswapLibraryError>` where `Ok` contains the calculated equivalent amount, and `Err` indicates an error such as insufficient amount or liquidity
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_a),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_a),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_b),
                 type_: I128,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: I128,
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(SoroswapLibraryError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: get_amount_out
     Docs: Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset.
           
           # Arguments
           
           * `amount_in` - The input amount of the asset.
           * `reserve_in` - Reserves of the input asset in the pair.
           * `reserve_out` - Reserves of the output asset in the pair.
           
           # Returns
           
           Returns `Result<i128, SoroswapLibraryError>` where `Ok` contains the calculated maximum output amount, and `Err` indicates an error such as insufficient input amount or liquidity.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_in),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_in),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_out),
                 type_: I128,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: I128,
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(SoroswapLibraryError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: get_amount_in
     Docs: Given an output amount of an asset and pair reserves, returns a required input amount of the other asset.
           
           # Arguments
           
           * `amount_out` - The output amount of the asset.
           * `reserve_in` - Reserves of the input asset in the pair.
           * `reserve_out` - Reserves of the output asset in the pair.
           
           # Returns
           
           Returns `Result<i128, SoroswapLibraryError>` where `Ok` contains the required input amount, and `Err` indicates an error such as insufficient output amount or liquidity.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_out),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_in),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(reserve_out),
                 type_: I128,
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: I128,
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(SoroswapLibraryError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: get_amounts_out
     Docs: Performs chained get_amount_out calculations on any number of pairs.
           
           # Arguments
           
           * `e` - The environment.
           * `factory` - The factory address.
           * `amount_in` - The input amount.
           * `path` - Vector of token addresses representing the path.
           
           # Returns
           
           Returns `Result<Vec<i128>, SoroswapLibraryError>` where `Ok` contains a vector of calculated amounts, and `Err` indicates an error such as an invalid path.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(factory),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_in),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(path),
                 type_: Vec(
                     ScSpecTypeVec {
                         element_type: Address,
                     },
                 ),
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Vec(
                         ScSpecTypeVec {
                             element_type: I128,
                         },
                     ),
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(SoroswapLibraryError),
                         },
                     ),
                 },
             ),
         ],
     )

 • Function: get_amounts_in
     Docs: Performs chained get_amount_in calculations on any number of pairs.
           
           # Arguments
           
           * `e` - The environment.
           * `factory` - The factory address.
           * `amount_out` - The output amount.
           * `path` - Vector of token addresses representing the path.
           
           # Returns
           
           Returns `Result<Vec<i128>, SoroswapLibraryError>` where `Ok` contains a vector of calculated amounts, and `Err` indicates an error such as an invalid path.
     Inputs: VecM(
         [
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(factory),
                 type_: Address,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(amount_out),
                 type_: I128,
             },
             ScSpecFunctionInputV0 {
                 doc: StringM(),
                 name: StringM(path),
                 type_: Vec(
                     ScSpecTypeVec {
                         element_type: Address,
                     },
                 ),
             },
         ],
     )
     Output: VecM(
         [
             Result(
                 ScSpecTypeResult {
                     ok_type: Vec(
                         ScSpecTypeVec {
                             element_type: I128,
                         },
                     ),
                     error_type: Udt(
                         ScSpecTypeUdt {
                             name: StringM(SoroswapLibraryError),
                         },
                     ),
                 },
             ),
         ],
     )


